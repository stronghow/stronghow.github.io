{"meta":{"title":"博客","subtitle":null,"description":"一只小坏蛋","author":"Stronghow","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-07-26T09:56:02.000Z","updated":"2017-07-26T09:56:35.577Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-26T09:54:22.000Z","updated":"2017-07-26T09:55:42.209Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql常用操作","slug":"mysql常用操作","date":"2018-04-16T08:52:06.000Z","updated":"2018-04-16T09:33:15.214Z","comments":true,"path":"2018/04/16/mysql常用操作/","link":"","permalink":"http://yoursite.com/2018/04/16/mysql常用操作/","excerpt":"","text":"启动数据库在管理员权限下cmd1net start mysql51 关闭数据库在管理员权限下cmd1net stop mysql51 连接数据库1mysql -uroot -p 显示所有数据库1show databases; 使用数据库1use dataname; 显示当前数据库下的表1show tables","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"myeclipse","slug":"myeclipse","date":"2018-03-26T11:43:28.000Z","updated":"2018-03-26T11:51:37.597Z","comments":true,"path":"2018/03/26/myeclipse/","link":"","permalink":"http://yoursite.com/2018/03/26/myeclipse/","excerpt":"","text":"myeclipse创建并运行web项目 展开WebRoot文件夹就可以看到有一个默认的index.jsp 选中启动 src/jdbc.properties 下 设置 jdbc.properties 中的 hibernate.show_sql=true 可以显示 hibernate生成的SQL语句","categories":[],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"http://yoursite.com/tags/javaweb/"},{"name":"myeclipse","slug":"myeclipse","permalink":"http://yoursite.com/tags/myeclipse/"}]},{"title":"VMware虚拟机","slug":"VMware虚拟机","date":"2018-03-25T11:30:18.000Z","updated":"2018-03-25T11:33:07.080Z","comments":true,"path":"2018/03/25/VMware虚拟机/","link":"","permalink":"http://yoursite.com/2018/03/25/VMware虚拟机/","excerpt":"","text":"VMware默认的虚拟机存放地点是我的文档→VMware Machine里面，在里面找到vdmx文件双击打开","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/categories/虚拟机/"}],"tags":[{"name":"虚拟机，VMware","slug":"虚拟机，VMware","permalink":"http://yoursite.com/tags/虚拟机，VMware/"}]},{"title":"如何学习","slug":"如何学习","date":"2018-03-21T10:54:02.000Z","updated":"2018-03-21T10:54:02.518Z","comments":true,"path":"2018/03/21/如何学习/","link":"","permalink":"http://yoursite.com/2018/03/21/如何学习/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java编程思想读后感","slug":"java编程思想读后感","date":"2018-03-08T04:58:43.000Z","updated":"2018-03-18T12:02:08.551Z","comments":true,"path":"2018/03/08/java编程思想读后感/","link":"","permalink":"http://yoursite.com/2018/03/08/java编程思想读后感/","excerpt":"","text":"对象导论 类实际上就是一个数据类型，他描诉了具有相同特性（数据元素）和行为（功能）的对象集合 对象具有状态、行为、标识 每个对象拥有内部数据和方法，在内存中都有唯一的地址 程序员通过定义类来适应问题 接口定义了某一特定对象所能发出的请求 将对象看作是服务 提供者 ，可以提高对象的内聚性。内聚性是让对象可以很好的完成一项任务，而不是试图做更多的事情。 新的类可以由任意数量、 任意类型的其他对象以任意可以实现心的类中想要的功能的方式所组成。 隐藏是为了不让调用者知道没必要知道的部分，方便创建者修改内部的实现方法，而不必担心影响到调用者 继承可以方便我们复用以前的代码，提高效率 多态就是把对象当作它的基类的对象对待。这使得人们可以编写出不依赖于特定类型的代码，不受添加新类型影响 多态调用方法时，编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查（无法提供此类型保证的语言被称为弱类型的），但是并不知道将被执行的确切代码 Java中动态绑定是默认行为，即函数的后期绑定 单根继承结构是垃圾回收的实现变得容易得多，因为所有对象具有 其类型信息，C++多继承 是为了兼容C 容器：从设计的观点来看，真正需要的只是 一个 可以被操作，从而解决问题的序列。然而事实并不是，原因有：第一，不同的容器提供了不同类型的接口和外部行为。第二，不同的容器对于不同的操作有不同的效率。比如ArrayList和LinkedList 参数化类型就是 一个编译器可以自动定制作用于特定类型上的类，即泛型，为了减少向下转型和运行时检查多需要的 额外时间。 在栈中创建存储空间和释放储存空间通常各需要一条汇编指令即可。分别对应将栈顶向下移动和栈顶指针向上移动。 动态方式有这样一个一般性的逻辑假设：对象趋向于复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大的 冲击 Java完全采用了动态内存分配方式（基本类型只是一种特列）。每当想要创建新对象时就要使用new关键字来创建此对象的动态实例 多线程（并发）编程，提高响应速度，隐患：共享资源 一切都是对象1.用引用操作对象2.所 有 这 一 切 在 Java 里 都 得 到 了 简 化 。 一 切 都 被 视 为 对 象 ， 因 此 可 采 用 单 一 固 定 的 语 法 。 尽管 一 切 都 看 作 对 象 ， 但 操 纵 的 标 识 符 实 际 上 是 对 象 的 一 个 “ 引 用 ” (reference) 。 可 以 将 这 一情 形 想 像 成 用 遥 控 器 （ 引 用 ） 来 操 纵 电 视 机 〈 对 象 )。只 要 握 住 这 个 遥 控 器 ， 就 能 保 持 与 电 视 机的 连 接 。 当 有 人 想 改 变 频 道 或 者 减 小 音 量 时 ， 实 际 操 控 的 是 遥 控 器 〈 引 用 ), 再 由 遥 控 器 来 调 控电 视 机 （ 对 象 ） 。 如 果 想 在 房 间 里 四 处 走 走 ， 同 时 仍 能 调 控 电 视 机 ， 那 么 只 需 携 带 遥 控 器 （ 引 用 ）而 不 是 电 视 机 （ 对 象 ),此 外 ， 即 使 没 有 电 视 机 ， 遥 控 器 亦 可 独 立 存 在 。 也 就 是 说 ， 你 拥 有 一 个 引 用 ， 并 不 一 定 需要 有 一 个 对 象 与 它 关 联 。 因 此 ， 如 果 想 操 纵 一 个 词 或 句 子 ， 则 可 以 创 建 一 个 String 引 用 ： 寄存器位于CPU内部，是最快的存储区 堆栈位于通用RAM（ 随机访问存储器 ）中。 创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，对象的引用存储在其中 堆一种通用的内存池（也位于RAM区），用于存放所有的Java对象。编译器不需要知道存储的数据在堆里存活多长时间 常量存储通常直接放程序代码内部，或将其放在ROM（只读存储器）中 非RAM储存 流对象和持久化对象。在流对象中，对象通常转化成字节流，通常被发送给另一台机器。在”持久化对象“中，对象被放在磁盘上。 数组 Java确保数组会被初始化，而且不能在它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销以及运行时的下表检查为代价的。当创建一个数组对象时，实际上就是创建了一个引用数组，并且自动初始化为null。创建基本数据类型的数组时，初始化内存，全部置0 作用域由花括号的位置决定。当用new创建一个Java对象时，它可以存活于作用域之外。10.若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值，但是不适用于局部变量11.方法名和参数列表（合起来被称为”方法签名“）唯一标识方法 Java中的方法只能作为类的一部分来创建 javadoc 用来生成java文档 操作数 将float或者double转型为整型值时，总是对该数字执行截尾，如果想要得到舍入的结果，就需要使用java.lang.Math中的round() 方法 流程控制 循环语句可以带标签，break和continue可以与标签组合使用 foreach 增强型for语句 初始化和清理 构造函数没有返回值 不以返回区分重载方法是因为：有时你并不关心方法的返回值，你想要的是方法调用的其他效果（这常被称为”为了副作用而调用“），这是你可能会调用方法而忽略其返回值。所以，如果像这样调用方法：1f() 此时Java如何才能判断该调用哪一个f()呢？ this关键字如 果 有 同 一 类 型 的 两 个 对 象 ， 分 别 是 a 和 b 。 你 可 能 想 知 道 ， 如 何 才 能 让 这 两 个 对 象 都 能 调用 peel() 方 法 呢 ：12345678910/ / ： initiaLization/BananaPeel.javaclass Banana &#123; void peel(int i) &#123; /* ... */ &#125; &#125;public c1ass BananaPeel &#123;public static void main(String[] args) &#123; Banana a = new Banana(), b = new Banana(); a.peel(1); b.peel(2); &#125;&#125; ///:~ 如 果 只 有 一 个 peel()方 法 ， 它 如 何 知 道 是 被 a 还 是 被 b 所 调 用 的 呢 ？为 了 能 用 简 便 、 面 向 对 象 的 语 法 来 编 写 代 码 一 一 一 即 “ 发 送 消 息 给 对 象” , 编 译 器 做 了 一 些 幕后 工 作 。 它 暗 自 把 “ 所 操 作 对 象 的 引 用 ” 作 为 第 一 个 参 数 传 递 给 peel() 。 所 以 上 述 两 个 方 法 的 调用 就 变 成 了 这 样 ：12Banana.peel(a, l);Banana.peel(b. 2); 这 是 内 部 的 表 示 形 式 。 我 们 并 不 能 这 样 书 写 代 码 ， 并 试 图 通 过 编 译 ； 但 这 种 写 法 的 确 能 帮你 了 解 实 际 所 发 生 的 事 情 。它还能调用构造器4.Java里的对象并非总是被垃圾回收，或者回句话说：1231.对象可能不被垃圾回收2.垃圾回收并不等于“析构”3.垃圾回收只与内存有关 垃 圾 回 收 器 工 作 时 ， 将 一 面 回 收 空 间 ， 一 面 使 堆 中 的 对 象 紧 凑 排 列 ，这 样 “ 堆 指 针 ” 就 可 以 很 容 易 移 动 到 更 近 传 送 带 的 开 始 处 ， 也 就 尽 量 避 免 了 页 面 错 误 。 通 过垃 圾 回 收 器 对 对 象 重 新 排 列 ， 实 现 了 一 种 高 速 的 、 有 无 限 空 间 可 供 分 配 的 堆 模 型 。在 一 些 更 快 的 模 式 中 ， 垃 圾 回 收 器 并 非 基 于 引 用 记 数 技 术 。 它 们 依 据 的 思 想 是 ： 对 任 何 “ 活 ” 的 对 象 ， 一 定 能 最 终 追 溯 到 其 存 活 在 堆 栈 或 静 态 存 储 区 之 中 的 引 用 。 这 个 引 用 链 条 可 能 会穿 过 数 个 对 象 层 次 。 由 此 ， 如 果 从 堆 栈 和 静 态 存 储 区 开 始 ， 遍 历 所 有 的 引 用 ， 就 能 找 到 所 有“ 活 ” 的 对 象 。 对 于 发 现 的 每 个 引 用 ， 必 须 追 踪 它 所 引 用 的 对 象 ， 然 后 是 此 对 象 包 含 的 所 有 引 用 ，如 此 反 复 进 行 ， 直 到 “ 根 源 于 堆 栈 和 静 态 存 储 区 的 引 用 “ 所 形 成 的 网 络 仝 部 被 访 问 为 止 。 你 所访 问 过 的 对 象 须 都 是 “ 活 ” 的 。 注 意 ， 这 就 解 决 了 “ 交 互 自 引 用 的 对 象 组 ” 的 问 题 一 一 这 种现 象 根 本 不 会 被 发 现 ， 因 此 也 就 被 自 动 回 收 了 。在 这 种 方 式 下 ， Java 虚 拟 机 将 采 用 一 种 自 适 应 的 垃 圾 回 收 技 术 。 至 于 如 何 处 理 找 到 的 存 活对 象 ， 取 决 于 不 同 的 Java 虚 拟 机 实 现 。 有 一 种 做 法 名 为 停 止 一 复 制 (stop-and-copy)o 显 然 这 意 味着 ， 先 暂 停 程 序 的 运 行 （ 所 以 它 不 属 于 后 台 回 收 模 式 ） ， 然 后 将 所 有 存 活 的 对 象 从 当 前 堆 复 制 到另 一 个 堆 ， 没 有 被 复 制 的 全 部 都 是 垃 圾 。 当 对 象 被 复 制 到 新 堆 时 ， 它 们 是 一 个 挨 着 一 个 的 ， 所以 新 堆 保 持 紧 凑 排 列 ， 然 后 就 可 以 按 前 述 方 法 简 单 、 直 接 地 分 配 新 空 间 了 。当 把 对 象 从 一 处 搬 到 另 一 处 时 ， 所 有 指 向 它 的 那 些 引 用 都 老 须 修 正 。 位 于 堆 或 静 态 存 储 区的 引 用 可 以 直 接 被 修 正 ， 但 可 能 还 有 其 他 指 向 这 些 对 象 的 引 用 ， 它 们 在 遍 历 的 过 程 中 才 能 被 找到 （ 可 以 想 像 成 有 个 表 格 ， 将 旧 地 址 映 射 至 新 地 址 ） 。对 于 这 种 所 谓 的 “ 复 制 式 回 收 器 “ 而 言 ， 效 率 会 降 低 ， 这 有 两 个 原 因 。 首 先 ， 得 有 两 个 堆 ，然 后 得 在 这 两 个 分 离 的 堆 之 间 来 回 捣 腾 ， 从 而 得 维 护 比 实 际 需 要 多 一 倍 的 空 间 。 某 些 Ja 、 ‘ a 虚 拟机 对 此 问 题 的 处 理 方 式 是 ， 按 需 从 堆 中 分 配 几 块 较 大 的 内 存 ， 复 制 动 作 发 生 在 这 些 大 块 内 存之 间 。第 二 个 问 题 在 于 复 制 。 程 序 进 人 稔 定 状 态 之 后 ， 可 能 只 会 产 生 少 量 垃 圾 ， 甚 至 没 有 垃 圾 。尽 管 如 此 ， 复 制 式 回 收 器 仍 然 会 将 所 有 内 存 自 一 处 复 制 到 另 一 处 ， 这 很 浪 费 。 为 了 避 免 这 种 情 形 ， 一 些 Java 虚 拟 机 会 进 行 检 查 ： 要 是 没 有 新 垃 圾 产 生 ， 就 会 转 换 到 另 一 种 工 作 模 式 〈 即 “ 自适 应 ” )。这 种 模 式 称 为 标 记 一 清 扫 （ mark-and-sweep), sun 公 司 早 期 版 本 的 Java 虚 拟 机 使 用 了 这种 技 术 。 对 一 般 用 途 而 言 ， “ 标 记 一 清 扫 ” 方 式 速 度 相 当 慢 ， 但 是 当 你 知 道 只 会 产 生 少 量 垃 圾 甚至 不 会 产 生 垃 圾 时 ， 它 的 速 度 就 很 快 了 。“ 标 记 一 清 扫 “ 所 依 据 的 思 路 同 样 是 从 堆 栈 和 静 态 存 储 区 出 发 ， 遍 历 所 有 的 引 用 ， 进 而 找 出所 有 存 活 的 对 象 。 当 它 找 到 一 个 存 活 对 象 ， 就 会 给 对 象 设 一 个 标 记 ， 这 个 过 程 中 不 会 回 收 任何 对 象 。 只 有 仝 部 标 记 工 作 完 成 的 时 候 ， 清 理 动 作 才 会 开 始 。 在 清 理 过 程 中 ， 没 有 标 记 的 对 象将 被 释 放 ， 不 会 发 生 任 何 复 制 动 作 。 所 以 剩 下 的 堆 空 间 是 不 连 续 的 ， 垃 圾 回 收 器 要 是 希 望 得 到连 续 空 间 的 话 ， 就 得 重 新 整 理 剩 下 的 对 象 。“ 停 止 一 复 制 ” 的 意 思 是 这 种 垃 圾 回 收 动 作 不 是 在 后 台 进 行 的 ； 相 反 ， 垃 圾 回 收 动 作 发 生 的同 时 ， 程 序 将 会 被 暂 停 。 在 sun 公 司 的 文 档 中 会 发 现 ， 许 多 参 考 文 献 将 垃 圾 回 收 视 为 低 优 先 级的 后 台 进 程 ， 但 事 实 上 垃 圾 回 收 器 在 Sun 公 司 早 期 版 本 的 Java 虚 拟 机 中 并 非 以 这 种 方 式 实 现 的 。当 可 用 内 存 数 量 较 低 时 ， Sun 版 本 的 垃 圾 回 收 器 会 暫 停 运 行 程 序 ， 同 样 ， “ 标 记 一 清 扫 ” 工 作 也老 须 在 程 序 暂 停 的 情 况 下 才 能 进 行 。如 前 文 所 述 ， 在 这 里 所 讨 论 的 Java 虚 拟 机 中 ， 内 存 分 配 以 较 大 的 “ 块 “ 为 单 位 。 如 果 对 象较 大 ， 它 会 占 用 单 独 的 块 。 严 格 来 说 ， “ 停 止 一 复 制 ” 要 求 在 释 放 旧 有 对 象 之 前 ， 必 须 先 把 所 有存 活 对 象 从 旧 堆 复 制 到 新 堆 ， 这 将 导 致 大 量 内 存 复 制 行 为 。 有 了 块 之 后 ， 垃 圾 回 收 器 在 回 收 的时 候 就 可 以 往 废 弃 的 块 里 拷 贝 对 象 了 。 每 个 块 都 用 相 应 的 代 数 (generauon count) 来 记 录 它 是 否还 存 活 。 通 常 ， 如 果 块 在 某 处 被 引 用 ， 其 代 数 会 增 加 《 垃 圾 回 收 器 将 对 上 次 回 收 动 作 之 后 新 分配 的 块 进 行 整 理 。 这 对 处 理 大 量 短 命 的 临 时 对 象 很 有 帮 助 。 垃 圾 回 收 器 会 定 期 进 行 完 整 的 清 理动 作 一 一 一 大 型 对 象 仍 然 不 会 被 复 制 （ 只 是 其 代 数 会 增 加 ） ， 内 含 小 型 对 象 的 那 些 块 则 被 复 制 并 整理 。 Java 虚 拟 机 会 进 行 监 视 ， 如 果 所 有 对 象 都 很 稳 定 ， 垃 圾 回 收 器 的 效 率 降 低 的 话 ， 就 切 换 到“ 标 记 一 清 扫 ” 方 式 ； 同 样 ， Java 虚 拟 机 会 跟 踪 “ 标 记 一 清 扫 ” 的 效 果 ， 要 是 堆 空 间 出 现 很 多 碎 片 ，就 会 切 换 回 “ 停 止 一 复 制 “ 方 式 。 这 就 是 “ 自 适 应 ” 技 术 ， 你 可 以 给 它 个 罗 嗦 的 称 呼 ： “ 自 适 应的 、 分 代 的 、 停 止 一 复 制 、 标 记 一 清 扫 ” 式 垃 圾 回 收 器 。Java 虚 拟 机 中 有 许 多 附 加 技 术 用 以 提 升 速 度 。 尤 其 是 与 加 载 器 操 作 有 关 的 ， 被 称 为 “ 即 时 ” (Just-In-Time ， JIT ） 编 译 器 的 技 术 。 这 种 技 术 可 以 把 程 序 全 部 或 部 分 翻 译 成 本 地 机 器 码 （ 这本 来 是 Java 虚 拟 机 的 工 作 ), 程 序 运 行 速 度 因 此 得 以 提 升 。 当 需 要 装 载 某 个 类 （ 通 常 是 在 为 该类 创 建 第 一 个 对 象 ） 时 ， 编 译 器 会 先 找 到 其 .class 文 件 ， 然 后 将 该 类 的 字 节 码 装 人 内 存 。 此 时 ，有 两 种 方 案 可 供 选 择 。 一 种 是 就 让 即 时 编 译 器 编 译 所 有 代 码 。 但 这 种 做 法 有 两 个 缺 陷 ： 这 种加 载 动 作 散 落 在 整 个 程 序 生 命 周 期 内 ， 累 加 起 来 要 花 更 多 时 间 ； 并 且 会 增 加 可 执 行 代 码 的 长度 （ 字 节 码 要 比 即 时 编 译 器 展 开 后 的 本 地 机 器 码 小 很 多 ） ， 这 将 导 致 页 面 调 度 ， 从 而 降 低 程 序速 度 。 另 一 种 做 法 称 为 惰 性 评 估 (lazy evaluauon) ， 意 思 是 即 时 编 译 器 只 在 必 要 的 时 候 才 编 译代 码 。 这 样 ， 从 不 会 被 执 行 的 代 码 也 许 就 压 根 不 会 被 JIT 所 编 译 。 新 版 JDK 中 的 Java HotSpot 技术 就 采 用 了 类 似 方 法 ， 代 码 每 次 被 执 行 的 时 候 都 会 做 一 些 优 化 ， 所 以 执 行 的 次 数 越 多 ， 它 的速 度 就 越 快 。 成员初始化 成员的自动初始化在构造器被调用之前发生 初始化顺序 在类内部，变量的定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。总 结 一 下**对 象 的 创 建 过 程** ， 假 设 有 个 名 为 Dog 的 类 ： 1. 即 使 没 有 显 式 地 使 用 static 关 键 字 ， 构 造 器 实 际 上 也 是 静 态 方 法 。 因 此 ， 当 首 次 创 建 类 型 为 Dog 的 对 象 时 （ 构 造 器 可 以 看 成 静 态 方 法 ） ， 或 者 Dog 类 的 静 态 方 法 / 静 态 域 首 次 被 访 问 时 ，Java 解 释 器 必 须 查 找 类 路 径 ， 以 定 位 Dog.class文 件 。2 ． 然 后 载 人 Dog.class（ 后 面 会 学 到 ， 这 将 创 建 一 个 CIass 对 象 ） ， 有 关 静 态 初 始 化 的 所 有 动 作 都 会 执 行 。 因 此 ， 静 态 初 始 化 只 在 Class 对 象 首 次 加 载 的 时 候 进 行 一 次 。 3 ． 当 用 new Dog0 创 建 对 象 的 时 候 ， 首 先 将 在 堆 上 为 Dog 对 象 分 配 足 够 的 存 储 空 间 。 4 ． 这 块 存 储 空 间 会 被 清 零 ， 这 就 自 动 地 将 Dog 对 象 中 的 所 有 基 本 类 型 数 据 都 设 置 成 了 默 认 值 （ 对 数 字 来 说 就 是 0 ， 对 布 尔 型 和 字 符 型 也 相 同 ） ， 而 引 用 则 被 设 置 成 了 null 。5 ． 执 行 所 有 出 现 于 字 段 定 义 处 的 初 始 化 动 作 。 6 ． 执 行 构 造 器 。 正 如 将 在 第 7 章 所 看 到 的 ， 这 可 能 会 牵 涉 到 很 多 动 作 ， 尤 其 是 涉 及 继 承 的 时 候 。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"编程思想","slug":"编程思想","permalink":"http://yoursite.com/tags/编程思想/"}]},{"title":"简历","slug":"简历","date":"2018-03-06T08:58:38.000Z","updated":"2018-03-11T08:41:55.970Z","comments":true,"path":"2018/03/06/简历/","link":"","permalink":"http://yoursite.com/2018/03/06/简历/","excerpt":"","text":"简历网址简历信息用户名 18100177484密码 9a简历制作怎么写简历中的自我评价？","categories":[{"name":"简历","slug":"简历","permalink":"http://yoursite.com/categories/简历/"}],"tags":[{"name":"简历","slug":"简历","permalink":"http://yoursite.com/tags/简历/"}]},{"title":"Linux添加模块遇到的坑","slug":"Linux添加模块遇到的坑","date":"2017-11-02T14:15:35.000Z","updated":"2017-11-02T14:35:23.286Z","comments":true,"path":"2017/11/02/Linux添加模块遇到的坑/","link":"","permalink":"http://yoursite.com/2017/11/02/Linux添加模块遇到的坑/","excerpt":"","text":"传递参数问题虽然 pid_t 是 int ,但是写成这样会 make 不通过123static pid_t pid;//参数申明smodule_param(pid,pid_t,0644); //参数说明 正确写法：123static pid_t pid;//参数申明smodule_param(pid,int,0644); //参数说明 find_task_by_vpid undefined 问题编译的时候出现下面的警告：WARNING: “find_task_by_vpid” [/home/work/try/va2pa/va2pa.ko] undefined! find_task_by_vpid没有被export(Kernel 里面还有定义该函数，但是没有导出symbol，所以 driver 里面不能再使用)。具体信息可以参考： 解决：1pid_task(find_vpid(pid), PIDTYPE_PID)","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"module","slug":"module","permalink":"http://yoursite.com/tags/module/"}]},{"title":"linux_4.x添加系统调用","slug":"linux-4-x添加系统调用","date":"2017-11-01T11:15:00.000Z","updated":"2017-11-10T06:58:57.500Z","comments":true,"path":"2017/11/01/linux-4-x添加系统调用/","link":"","permalink":"http://yoursite.com/2017/11/01/linux-4-x添加系统调用/","excerpt":"","text":"前提 Linux不同版本内核源码中的函数定义与引用查找网站4.x内核添加系统调用到官方网站下载源码我下的是4.13.8解压压缩包我们先切换到root用户,把下载好的内核压缩文件放到/usr/src下，然后进入这个目录12xz -d linux-4.13.8.tar.xztar -xvf linux-4.13.8.tar 清除编译历史1make mrproper 执行这条命令需要先安装一个包1sudo apt install libncurses5-dev 配置内核选项1make menuconfig 一般保持默认即可编译内核内 核 配 置 完 成 后 , 编 译 内 核 , 并 生 成 启 动 映 像 文 件 bzImage ( 位于./arch/x86_64/boot/bzImage):执行命令:1make 如果是多核 cpu 可使用1make -j4 来加快编译速度。4代表4个进程,编译过程可能出现如图错误：这是因为没有安装 openssl, openssl 的安装方法是:1apt-get install libssl-dev openssl 安装完成后,再执行 make 命令即可,需要较长时间 编译模块1make modules 第一次编译模块需要很长时间。 安装内核(1)安装模块:1make modules_install (2)安装内核:1#make install 配置 grub 引导程序1update-grub2 重启系统1reboo 查看内核版本1uname -a 添加系统调用首先，给出几个关键的路径：/usr/src/linux-4.13.8/arch/x86/include/asm/syscalls.h 自定义的系统调用函数声明/usr/src/linux-4.13.8/kernel/sys.c 自定义的系统调用函数实现/usr/src/linux-4.13.8/arch/x86/entry/syscalls/syscall_64.tbl 系统调用表 分配系统调用号,修改系统调用表查看系统调用表(./arch/x86/entyr/syscalls/syscall_64.tbl)1333 64 mysetnice sys_mysetnice 每个系统调用在表中占一表项,其格式为:1&lt;系统调用号&gt; &lt;commom/64/x32&gt; &lt;系统调用名&gt; &lt;服务例程入口地址&gt; 在syscalls.h文件内定义函数声明1asmlinkage int sys_mysetnice(pid_t pid, int flag, int nicevalue); 返回值、参数和正常定义函数一样，函数名一定要以 sys_ 开头asmlinkage不要缺少。函数定义前加宏asmlinkage ,表示这些函数通过堆栈而不是通过寄存器传递参数。 在sys.c内实现上面声明的函数123456789101112131415161718192021asmlinkage int sys_mysetnice(pid_t pid, int flag, int nicevalue)&#123; struct pid * kpid; struct task_struct * task; int nicebef; kpid = find_get_pid(pid);/* 返回pid */ task = pid_task(kpid, PIDTYPE_PID);/* 返回task_struct */ nicebef = task_nice(task);/* 返回进程当前nice值 */ if(flag == 1) &#123; set_user_nice(task, nicevalue);/* 修改进程nice值 */ printk(&quot;修改前nice值：%d\\t修改后nice值：%d\\n&quot;, nicebef, nicevalue); return 0; &#125; else if(flag == 0) &#123; printk(&quot;该进程的nice值为%d\\n&quot;, nicebef); return 0; &#125; return EFAULT;&#125; 重新编译内核编写测试用例Linux nice值范围 -20~1912345678910111213141516171819#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; pid_t tid; int nicevalue,resualt; tid = getpid(); printf(&quot;pid = %d\\n&quot;,tid); resualt = syscall(333,tid,0,0);//read printf(&quot;resualt = %ld\\n&quot;,resualt); resualt = syscall(333,tid,1,1);//set printf(&quot;resualt = %ld\\n&quot;,resualt); resualt = syscall(333,tid,0,0);//read printf(&quot;resualt = %ld\\n&quot;,resualt); return 0;&#125; 编译1gcc -o mysetnice.out mysetnice.c 执行1./mysetnice.out 测试结果1sudo dmesg","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"系统调用","slug":"系统调用","permalink":"http://yoursite.com/tags/系统调用/"}]},{"title":"linux搭建hexo","slug":"linux搭建hexo","date":"2017-11-01T07:05:14.000Z","updated":"2017-11-01T07:56:58.322Z","comments":true,"path":"2017/11/01/linux搭建hexo/","link":"","permalink":"http://yoursite.com/2017/11/01/linux搭建hexo/","excerpt":"","text":"安装nodejs 去官方网站下载已经编译好的包 解压压缩包，设置全局路径1sudo ln -s /media/stronghow/Stronghow/下载/ode-v8.9.0-linux-x64/bin/node /usr/local/bin/node 其中 /media/stronghow/Stronghow/下载/ode-v8.9.0-linux-x64/bin/node 是解压包的路径要在 /media/stronghow/Stronghow/下载/ode-v8.9.0-linux-x64/bin 下执行，减少不必要的麻烦 同理，设置npm 1sudo ln -s /media/stronghow/Stronghow/下载/ode-v8.9.0-linux-x64/bin/npm /usr/local/bin/npm 配置npm的镜像为国内淘宝镜像，不然有的包下载不了（比如 hexo, 好坑） 1sudo npm install -g cnpm --registry=https://registry.npm.taobao.org 设置cnpm为全局路径 1sudo ln -s /media/stronghow/Stronghow/下载/ode-v8.9.0-linux-x64/bin/cnpm /usr/local/bin/cnpm 安装hexo 1sudo cnpm insatll hexo-cli -g 设置hexo为全局路径 1sudo ln -s /media/stronghow/Stronghow/下载/ode-v8.9.0-linux-x64/bin/hexo /usr/local/bin/hexo","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"在windows下安装flex和bison","slug":"在windows下安装flex和bison","date":"2017-10-21T13:29:29.000Z","updated":"2017-10-22T12:20:00.345Z","comments":true,"path":"2017/10/21/在windows下安装flex和bison/","link":"","permalink":"http://yoursite.com/2017/10/21/在windows下安装flex和bison/","excerpt":"","text":"词法分析器LEX是UNIX的工具，因此我们需要使用FLEX代替,使得在windows下使用；配对：LEX和YACCFLEX和BISONJFLEX和JavaCUP 下载得网址:flexbison 最偷懒得方法就是直接下载 Complete package, except sources打开右键我得电脑→属性→內容→高级→环境变量→系统变量→path→编辑加入;C:\\Program Files(x86)\\GnuWin32\\bin;cmd键入flex -Vbison -V这样就能看到正确得信息就表示安装成功了！！ 使用flex步骤一：123456789101112131415161718192021%&#123; //声明一些变量或函数 %&#125; //定义正则表达式 //比如: //num ([0-9])+ //左边为符号，右边为正则表达式 %% //定义一系列的动作，即如果匹配了上面定义的某个正则表达式之后的动作,此动作是C语言的语句 //比如： //&#123;num&#125; &#123;printf(&quot;num&quot;);&#125; //左边为&#123;模式&#125;,右边为&#123;C语句&#125;; %% void main() //执行主函数 &#123; yylex(); //开始解析语句,内置函数 //定义C语言语句 &#125; int yywrap() &#123; return 1; &#125; 示列（name.l）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199%&#123;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;%&#125;/*标识符*/id [a-zA-Z_][a-zA-Z_0-9]*/*常量*/num ([1-9][0-9]*|[0])|([0][Xx]([1-9][0-9]*|[0]))|([0][0-7])|([0-9]*[.][0-9]+([eE][+-]?[0-9]*|[0])?f?) ch \\&apos;([^&apos;])&#123;1&#125;\\&apos;str \\&quot;(\\\\.|[^&quot;\\\\])*\\&quot;/*关键字*/kw_int intkw_float floatkw_double doublekw_char charkw_void voidkw_if ifkw_then thenkw_else elsekw_switch switchkw_case casekw_default defaultkw_while whilekw_do dokw_for forkw_break breakkw_continue continuekw_return return/*运算符*/add [+]sub [-]mul [*]div [/]mod [%]inc [+][+]dec [-][-]not [!]and [&amp;][&amp;]or [|][|]assign [=]gt [&gt;]ge [&gt;][=]lt [&lt;]le [&lt;][=]equ [=][=]nequ [!][=]/*分解符*/comma [,]colon [:]simcon [;]lparen \\(rparen \\)lbracket \\[rbracket \\]lbrac \\&#123;rbrac \\&#125;%%&#123;kw_int&#125; |&#123;kw_float&#125; |&#123;kw_double&#125; |&#123;kw_char&#125; |&#123;kw_void&#125; |&#123;kw_if&#125; |&#123;kw_then&#125; |&#123;kw_else&#125; |&#123;kw_switch&#125; |&#123;kw_case&#125; |&#123;kw_default&#125; |&#123;kw_while&#125; |&#123;kw_do&#125; |&#123;kw_for&#125; |&#123;kw_break&#125; |&#123;kw_continue&#125; |&#123;kw_return&#125; &#123; printf(&quot;&lt;kw_%s, %s&gt;\\n&quot;, yytext, yytext);&#125;&#123;ch&#125; &#123; printf(&quot;&lt;ch, %s&gt;\\n&quot;, yytext);&#125;&#123;str&#125; &#123; printf(&quot;&lt;str, %s&gt;\\n&quot;, yytext);&#125;&#123;id&#125; &#123; printf(&quot;&lt;id, %s&gt;\\n&quot;, yytext);&#125;&#123;num&#125; &#123; printf(&quot;&lt;num, %s&gt;\\n&quot;, yytext);&#125;&#123;add&#125; &#123; printf(&quot;&lt;add, %s&gt;\\n&quot;, yytext);&#125;&#123;sub&#125; &#123; printf(&quot;&lt;sub, %s&gt;\\n&quot;, yytext);&#125;&#123;mul&#125; &#123; printf(&quot;&lt;mul, %s&gt;\\n&quot;, yytext);&#125;&#123;div&#125; &#123; printf(&quot;&lt;div, %s&gt;\\n&quot;, yytext);&#125;&#123;mod&#125; &#123; printf(&quot;&lt;mod, %s&gt;\\n&quot;, yytext);&#125;&#123;inc&#125; &#123; printf(&quot;&lt;inc, %s&gt;\\n&quot;, yytext);&#125;&#123;dec&#125; &#123; printf(&quot;&lt;dec, %s&gt;\\n&quot;, yytext);&#125;&#123;not&#125; &#123; printf(&quot;&lt;not, %s&gt;\\n&quot;, yytext);&#125;&#123;and&#125; &#123; printf(&quot;&lt;and, %s&gt;\\n&quot;, yytext);&#125;&#123;or&#125; &#123; printf(&quot;&lt;or, %s&gt;\\n&quot;, yytext);&#125;&#123;assign&#125; &#123; printf(&quot;&lt;assign, %s&gt;\\n&quot;, yytext);&#125;&#123;gt&#125; &#123; printf(&quot;&lt;gt, %s&gt;\\n&quot;, yytext);&#125;&#123;ge&#125; &#123; printf(&quot;&lt;ge, %s&gt;\\n&quot;, yytext);&#125;&#123;lt&#125; &#123; printf(&quot;&lt;lt, %s&gt;\\n&quot;, yytext);&#125;&#123;le&#125; &#123; printf(&quot;&lt;le, %s&gt;\\n&quot;, yytext);&#125;&#123;equ&#125; &#123; printf(&quot;&lt;equ, %s&gt;\\n&quot;, yytext);&#125;&#123;nequ&#125; &#123; printf(&quot;&lt;nequ, %s&gt;\\n&quot;, yytext);&#125;&#123;comma&#125; &#123; printf(&quot;&lt;comma, %s&gt;\\n&quot;, yytext);&#125;&#123;colon&#125; &#123; printf(&quot;&lt;colon, %s&gt;\\n&quot;, yytext);&#125;&#123;simcon&#125; &#123; printf(&quot;&lt;simcon, %s&gt;\\n&quot;, yytext);&#125;&#123;lparen&#125; &#123; printf(&quot;&lt;lparen, %s&gt;\\n&quot;, yytext);&#125;&#123;rparen&#125; &#123; printf(&quot;&lt;rparen, %s&gt;\\n&quot;, yytext);&#125;&#123;lbracket&#125; &#123; printf(&quot;&lt;lbracket, %s&gt;\\n&quot;, yytext);&#125;&#123;rbracket&#125; &#123; printf(&quot;&lt;rbracket, %s&gt;\\n&quot;, yytext);&#125;&#123;lbrac&#125; &#123; printf(&quot;&lt;lbrac, %s&gt;\\n&quot;, yytext);&#125;&#123;rbrac&#125; &#123; printf(&quot;&lt;rbrac, %s&gt;\\n&quot;, yytext);&#125;%%int yywrap() &#123; return 1;&#125;int main(int argc, char** argv) &#123; if (argc &gt; 1) &#123; if (!(yyin = fopen(argv[1], &quot;r&quot;))) &#123; perror(argv[1]); return 1; &#125; &#125; while (yylex()); return 0;&#125; 文本(Text.txt)12345678910int float &#123;&#125;()[] 0 0x0 0x123 123.5 .3e-10f = &gt;= || &amp;&amp; ! ; , this_is_an_id id123 if then else &apos;f&apos;&quot;bfgg&quot; 步骤二：123flex name.lgcc -o out.exe lex.yy.cout.exe Text.txt 结果123456789101112131415161718192021222324252627282930313233343536&lt;kw_int, int&gt; &lt;kw_float, float&gt; &lt;lbrac, &#123;&gt;&lt;rbrac, &#125;&gt;&lt;lparen, (&gt;&lt;rparen, )&gt;&lt;lbracket, [&gt;&lt;rbracket, ]&gt; &lt;num, 0&gt;&lt;num, 0x0&gt; &lt;num, 0x123&gt;&lt;num, 123.5&gt;&lt;num, .3e-10f&gt;&lt;assign, =&gt; &lt;ge, &gt;=&gt; &lt;or, ||&gt; &lt;and, &amp;&amp;&gt; &lt;not, !&gt; &lt;simcon, ;&gt; &lt;comma, ,&gt;&lt;id, this_is_an_id&gt;&lt;id, id123&gt;&lt;kw_if, if&gt; &lt;kw_then, then&gt; &lt;kw_else, else&gt;&lt;ch, &apos;f&apos;&gt;&lt;str, &quot;bfgg&quot;&gt; 注意rule组合使用同一函数时必须放最前面，否则报错即此段代码12345678910111213141516171819&#123;kw_int&#125; |&#123;kw_float&#125; |&#123;kw_double&#125; |&#123;kw_char&#125; |&#123;kw_void&#125; |&#123;kw_if&#125; |&#123;kw_then&#125; |&#123;kw_else&#125; |&#123;kw_switch&#125; |&#123;kw_case&#125; |&#123;kw_default&#125; |&#123;kw_while&#125; |&#123;kw_do&#125; |&#123;kw_for&#125; |&#123;kw_break&#125; |&#123;kw_continue&#125; |&#123;kw_return&#125; &#123; printf(&quot;&lt;kw_%s, %s&gt;\\n&quot;, yytext, yytext);&#125; 要放在最前面","categories":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/categories/编译原理/"}],"tags":[{"name":"词法分析器","slug":"词法分析器","permalink":"http://yoursite.com/tags/词法分析器/"},{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"},{"name":"bison","slug":"bison","permalink":"http://yoursite.com/tags/bison/"}]},{"title":"Android开发之AndroidAnnotations框架的使用","slug":"Android开发之AndroidAnnotations框架的使用","date":"2017-08-07T03:18:57.000Z","updated":"2017-08-07T07:55:43.048Z","comments":true,"path":"2017/08/07/Android开发之AndroidAnnotations框架的使用/","link":"","permalink":"http://yoursite.com/2017/08/07/Android开发之AndroidAnnotations框架的使用/","excerpt":"","text":"Android开发之AndroidAnnotations框架的使用遇到的问题 Warning:Android-apt plugin is incompatible with future version of android Gradle plugin. Please use ‘annotationProcessor’ configuration instead.解决","categories":[{"name":"Android开发","slug":"Android开发","permalink":"http://yoursite.com/categories/Android开发/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"},{"name":"AndroidAnnotations","slug":"AndroidAnnotations","permalink":"http://yoursite.com/tags/AndroidAnnotations/"}]},{"title":"AndroidSDK_Support自带夜间、日间模式切换详解","slug":"AndroidSDK-Support自带夜间、日间模式切换详解","date":"2017-08-05T07:10:47.000Z","updated":"2017-08-05T07:10:47.800Z","comments":true,"path":"2017/08/05/AndroidSDK-Support自带夜间、日间模式切换详解/","link":"","permalink":"http://yoursite.com/2017/08/05/AndroidSDK-Support自带夜间、日间模式切换详解/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android_Studio主题配置","slug":"Android-Studio主题配置","date":"2017-08-02T13:35:58.000Z","updated":"2017-08-02T13:35:58.348Z","comments":true,"path":"2017/08/02/Android-Studio主题配置/","link":"","permalink":"http://yoursite.com/2017/08/02/Android-Studio主题配置/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android_Studio从Git上Clone项目","slug":"Android-Studio从Git上Clone项目","date":"2017-08-02T02:08:27.000Z","updated":"2017-08-02T02:23:37.674Z","comments":true,"path":"2017/08/02/Android-Studio从Git上Clone项目/","link":"","permalink":"http://yoursite.com/2017/08/02/Android-Studio从Git上Clone项目/","excerpt":"","text":"在Android Studio中设置Git打开 File &rarr; setting, 得到如下图： 打开File &rarr; New &rarr; Project from Version Control &rarr; Git,弹出界面如下图：","categories":[{"name":"Android_studio","slug":"Android-studio","permalink":"http://yoursite.com/categories/Android-studio/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"mysql数据库的导入导出","slug":"mysql数据库的导入导出","date":"2017-07-30T13:33:33.000Z","updated":"2017-07-30T13:56:00.137Z","comments":true,"path":"2017/07/30/mysql数据库的导入导出/","link":"","permalink":"http://yoursite.com/2017/07/30/mysql数据库的导入导出/","excerpt":"","text":"导出数据库最常用导出数据库1mysqldump -u用户名 -p 数据库名&gt;保存路径\\xx.sql 注意：此备份只备份数据和数据结构，没有备份存储过程和触发器 导出所有数据库1mysqldump -u用户名 -p -a&gt;保存路径\\xx.sql 只导出数据不导出数据结构1mysqldump -u用户名 -p -t数据库名&gt;保存路径\\xx.sql 导出数据库中的触发器（Events）1mysqldump -u用户名 -p -e数据库名&gt;保存路径\\xx.sql 导出数据库中的存储过程和函数1mysqldump -u用户名 -p -r数据库名&gt;保存路径\\xx.sql 导入数据库1mysql -u用户名 -p 数据库名&lt;备份路径\\xx.sql","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"hexo+github搭建博客流程","slug":"hexo-github搭建博客流程","date":"2017-07-26T13:19:58.000Z","updated":"2017-07-26T13:34:53.937Z","comments":true,"path":"2017/07/26/hexo-github搭建博客流程/","link":"","permalink":"http://yoursite.com/2017/07/26/hexo-github搭建博客流程/","excerpt":"","text":"环境配置小茗同学的博客园 NexT主题配置为NexT主题添加文章阅读量统计功能 hexo之next主题优化整理 hexo next主题配置 Hexo-next主题个性化配置(细节多)","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"gihub","slug":"gihub","permalink":"http://yoursite.com/tags/gihub/"}]},{"title":"hexo部署到github遇到的坑","slug":"hexo部署到github遇到的坑","date":"2017-07-26T09:15:01.000Z","updated":"2017-07-26T10:18:12.693Z","comments":true,"path":"2017/07/26/hexo部署到github遇到的坑/","link":"","permalink":"http://yoursite.com/2017/07/26/hexo部署到github遇到的坑/","excerpt":"","text":"1. 部署到github无法存储图片解决： 注册七牛云 &rarr; 新建存储空间（对象存储） &rarr; 上传图片工具进行图片上传到七牛云 &rarr; 获取外链 2. markdown无法满足需求解决：直接写html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://yoursite.com/tags/github-pages/"}]},{"title":"windows下用cmd命令netstat查看系统端口使用情况","slug":"windows下用cmd命令netstat查看系统端口使用情况","date":"2017-07-26T07:19:33.000Z","updated":"2017-07-26T09:43:55.370Z","comments":true,"path":"2017/07/26/windows下用cmd命令netstat查看系统端口使用情况/","link":"","permalink":"http://yoursite.com/2017/07/26/windows下用cmd命令netstat查看系统端口使用情况/","excerpt":"","text":"大家可以在cmd窗口执行 查看一个端口被哪个进程占用，然后杀掉他 查看任务管理器 用pid查找程序","categories":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/categories/windows/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-24T07:19:30.174Z","updated":"2017-07-24T07:19:30.174Z","comments":true,"path":"2017/07/24/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}